# CLAUDE.md

Guidance for code agents working in this repository. Keep commits clean and avoid AI attribution.

## Critical Instructions
- Do not add “Co-Authored-By/Generated by …” footers to commits.
- Prefer linking to existing docs over repeating content.
- Use `docs/README.md` as the navigation root.

## Project Overview

TelHawk Stack is an OCSF‑compatible SIEM in Go with Splunk‑compatible ingestion and OpenSearch storage. Services: ingest → core → storage ↔ OpenSearch → query → web.

## Development Commands

### Building and Testing (minimal)

```bash
# Build one service
cd <service> && go build -o ../bin/<service> ./cmd/<service>
# Run tests
go test ./...
```

### Docker / Devtools

See `docs/LOCAL_DEVELOPMENT.md` and `docs/HELPER_SCRIPTS.md` for usage. Quick example:

```bash
docker-compose run --rm thawk auth whoami
```

### Internal Access & Scripts

Use the helpers documented in `docs/HELPER_SCRIPTS.md`.

**Example script** (`tmp/create_detection_rules.sh`):
```bash
#!/bin/bash
# Create multiple detection rules

RULES_API="http://rules:8084/api/v1/schemas"

for severity in critical high medium; do
  curl -s -X POST "$RULES_API" \
    -H "Content-Type: application/json" \
    -d "{
      \"model\": {...},
      \"view\": {\"severity\": \"$severity\", ...},
      \"controller\": {...}
    }" | jq -r '.id'
done
```

**File locations:**
- Scripts in `./tmp/` are accessible at `/tmp/` in the container (read/write)
- Scripts in `./scripts/` are accessible at `/scripts/` in the container (read-only)

**How it works:** Both tools use an Alpine-based Docker image (`telhawk-stack-devtools`) with curl, bash, jq, and wget. The image is automatically built and connected to the TelHawk internal network.

### Database Migrations

The auth service uses golang-migrate for database schema management:

```bash
# Migrations are automatically run on auth service startup
# Migration files: auth/migrations/*.sql

# To manually run migrations:
cd auth
# View migration status
migrate -database "postgres://telhawk:password@localhost:5432/telhawk_auth?sslmode=disable" -path migrations version

# Apply migrations
migrate -database "postgres://telhawk:password@localhost:5432/telhawk_auth?sslmode=disable" -path migrations up

# Rollback last migration
migrate -database "postgres://telhawk:password@localhost:5432/telhawk_auth?sslmode=disable" -path migrations down 1
```

### Generating Test Data (Event Seeder)

The event seeder generates realistic OCSF events for development and testing.

**Key features:**
- **Jittered distribution**: Events are evenly distributed across time with ±40% random jitter (not purely random)
- **Guaranteed coverage**: Requires minimum 1 event/day to prevent gaps
- **Homogeneous baseline**: Ideal for layering suspicious activity patterns on top

```bash
# 1. Create a HEC token (via web UI at http://localhost:3000/tokens or via API):
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}' \
  -c /tmp/cookies.txt

curl -b /tmp/cookies.txt -X POST http://localhost:3000/api/auth/api/v1/hec/tokens \
  -H "Content-Type: application/json" \
  -d '{"name":"Event Seeder"}'

# Note the token value from the response

# 2. Build and run the seeder:
cd tools/event-seeder
go build

# Default: 50,000 events over 90 days (no arguments needed except token)
./event-seeder -token YOUR_HEC_TOKEN

# Common seeder use cases:

# Quick development dataset (100 events over last hour):
./event-seeder -token YOUR_TOKEN -count 100 -time-spread 1h

# Dashboard population (1000 events over last hour):
./event-seeder -token YOUR_TOKEN -count 1000 -time-spread 1h

# Production-like dataset (default: 50k events over 90 days):
./event-seeder -token YOUR_TOKEN

# Massive load testing (100k events, fast as possible):
./event-seeder -token YOUR_TOKEN -count 100000 -batch-size 100

# Specific event types only:
./event-seeder -token YOUR_TOKEN -types auth,detection -count 500

# Custom time range (30 days of events):
./event-seeder -token YOUR_TOKEN -count 25000 -time-spread 720h
```
## Architecture
See `docs/SERVICES.md` for service flow and summaries.

### Supporting Services

- OpenSearch (9200, 9600)
- PostgreSQL for auth/rules where applicable
- Redis for rate limiting/caching where applicable

## Code Architecture

### Event Pipeline (Ingest → Core → Storage)

1. **Ingest Service** receives raw events via HEC endpoint (`/services/collector/event`)
   - Validates HEC token via auth service (with 5-min caching)
   - IP-based and token-based rate limiting (Redis-backed)
   - Forwards to core service for normalization
   - Implements retry with exponential backoff (3 attempts, ~700ms total)
   - Supports HEC ack channel for event tracking

2. **Core Service** normalizes events to OCSF format
   - Registry pattern matches raw event format/source_type to normalizer
   - 77 auto-generated normalizers (one per OCSF class) in `core/internal/normalizer/generated/`
   - HECNormalizer as fallback for generic HEC events
   - Validation chain ensures OCSF compliance
   - Failed events → Dead Letter Queue (file-based at `/var/lib/telhawk/dlq`)
   - Successful events → forwarded to storage service

3. **Storage Service** persists to OpenSearch
   - Bulk indexing with automatic retry (3 attempts, exponential backoff)
   - Index pattern: `telhawk-events-YYYY.MM.DD`
   - OCSF-optimized field mappings

**Key Files:**
- `core/internal/pipeline/pipeline.go`: Orchestrates normalization and validation
- `core/internal/normalizer/normalizer.go`: Registry and interface definitions
- `ingest/internal/handlers/hec.go`: HEC endpoint implementation
- `storage/internal/client/opensearch.go`: OpenSearch bulk operations

### Authentication Flow

1. User login (`POST /api/v1/auth/login`) → returns JWT access token + refresh token
2. Access token used in `Authorization: Bearer <token>` header
3. Token validation endpoint (`POST /api/v1/auth/validate`) called by other services
4. Refresh tokens stored in PostgreSQL sessions table with revocation support
5. HEC tokens stored separately with user association
6. All auth events forwarded to ingest service as OCSF Authentication events (class_uid: 3002)

**Key Files:**
- `auth/internal/repository/postgres.go`: Database operations
- `auth/pkg/tokens/jwt.go`: JWT generation and validation
- `auth/migrations/001_init.up.sql`: Database schema

### API Conventions (JSON:API)

All new and modernized HTTP APIs follow the JSON:API 1.0 specification (https://jsonapi.org/format/):
- Content type: `application/vnd.api+json` for requests and responses
- Top-level members: `data`, `errors`, `meta`, `links`
- Resources: `type`, `id`, `attributes`, optional `relationships`
- Pagination: `page[number]`, `page[size]` (or cursor when specified)
- Filtering and sorting use JSON:API conventions (e.g., `filter[...]`, `sort`)
- Errors use JSON:API error objects with `status`, `code`, `title`, `detail`

Example resources include Saved Searches (`type: saved-search`), where immutable versioning is represented in attributes (e.g., `version_id`, lifecycle timestamps) and ownership is conveyed via `relationships` to `user`.

### OCSF Normalization

The system uses a code generator approach for OCSF compliance:

1. **OCSF Schema** (`ocsf-schema/`): Git submodule tracking OCSF 1.1.0 schema
2. **Generator** (`tools/normalizer-generator/`): Reads OCSF schema, generates Go normalizers
3. **Generated Code** (`core/internal/normalizer/generated/`): One file per OCSF class (77 total)
4. **Runtime**: Registry matches events to normalizers based on source_type patterns

Each normalizer implements:
- Field mapping (common variants → OCSF standard fields)
- Event classification (category_uid, class_uid, activity_id, type_uid)
- Metadata enrichment (product info, timestamps, severity)

**Key Files:**
- `tools/normalizer-generator/main.go`: Code generator
- `core/internal/normalizer/registry.go`: Normalizer registration
- `core/pkg/ocsf/event.go`: Base OCSF event structure

### Configuration Management

All services follow a consistent pattern:
- **YAML config file** embedded in Docker images at `/etc/telhawk/<service>/config.yaml`
- **Environment variables** override YAML settings (12-factor app compliant)
- **Viper** library for config loading
- **No CLI arguments** for configuration

Environment variable naming: `<SERVICE>_<SECTION>_<KEY>`
Examples:
- `AUTH_SERVER_PORT=8080`
- `INGEST_AUTH_URL=http://auth:8080`
- `QUERY_OPENSEARCH_PASSWORD=secret`

**Key Files:**
- `auth/config.yaml`, `ingest/config.yaml`, etc.: Default configurations
- `docker-compose.yml`: Shows environment variable overrides
- `.env.example`: Template for local overrides

## TLS/Certificate Management

The stack uses mutual TLS (mTLS) for service-to-service communication:

1. **Certificate Generation**: Two init containers create certificates before services start
   - `telhawk-certs`: Generates certs for Go services (auth, ingest, core, storage, query, web)
   - `opensearch-certs`: Generates certs for OpenSearch

2. **Certificate Storage**: Shared Docker volumes
   - `telhawk-certs:/certs` - mounted read-only to all Go services
   - `opensearch-certs:/certs` - mounted read-only to OpenSearch

3. **TLS Configuration**: Controlled via environment variables
   - `<SERVICE>_TLS_ENABLED=true/false`: Enable TLS for each service
   - `<SERVICE>_TLS_SKIP_VERIFY=true/false`: Skip cert verification (dev only)

**Key Files:**
- `certs/generator/Dockerfile`: Go service certificate generator
- `opensearch/cert-generator/Dockerfile`: OpenSearch certificate generator
- `docs/TLS_CONFIGURATION.md`: Detailed TLS setup guide

## Important Implementation Details

### Database Schema Patterns

**PostgreSQL - Immutability Pattern**:
The system follows an immutable database pattern for audit trails and versioning:

**Core Principles**:
- **UUID v7**: All new IDs use `uuid.NewV7()` for time-ordered UUIDs (better B-tree performance than random UUIDs)
- **Lifecycle Timestamps**: Use `disabled_at`, `deleted_at`, `hidden_at` instead of boolean flags for audit trails
- **Append-Only Pattern**: INSERT for new content, UPDATE only for lifecycle timestamps
- **No Physical Deletes**: Soft delete with `deleted_at` timestamp and `deleted_by` user reference
- **Immutable Versioning**: Content changes create new rows with same stable ID but new version ID

**Auth Service (users, hec_tokens, sessions)**:
- UUIDs: UUID v7 primary keys
- Lifecycle: `created_at`, `disabled_at`, `disabled_by`, `deleted_at`, `deleted_by`
- No `enabled` boolean or `updated_at` timestamp
- Helper methods: `IsActive()` checks lifecycle state
- Example:
  ```sql
  CREATE TABLE users (
      id UUID PRIMARY KEY,
      username VARCHAR(255) NOT NULL UNIQUE,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      disabled_at TIMESTAMP,
      disabled_by UUID REFERENCES users(id),
      deleted_at TIMESTAMP,
      deleted_by UUID REFERENCES users(id)
  );
  ```

**Rules Service (detection_schemas)**:
- Immutable versioning: Same `id` (stable) + new `version_id` (version-specific) per update
- Window functions calculate version numbers on read (no race conditions)
- Lifecycle: `created_at`, `disabled_at`, `disabled_by`, `hidden_at`, `hidden_by`
- Server-generated UUIDs: Users NEVER provide `id` or `version_id` in requests
- POST creates new rule (server generates both IDs), PUT creates new version (reuses `id`, new `version_id`)
- Example:
  ```sql
  CREATE TABLE detection_schemas (
      id UUID NOT NULL,                 -- Stable identifier (groups versions)
      version_id UUID PRIMARY KEY,      -- Version-specific UUID (UUID v7)
      model JSONB NOT NULL,
      view JSONB NOT NULL,
      controller JSONB NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      disabled_at TIMESTAMP,
      disabled_by UUID,
      hidden_at TIMESTAMP,
      hidden_by UUID
  );
  ```

**Alerting Service (cases, case_alerts)**:
- Cases: UUID v7 IDs, mutable status field (open, in_progress, resolved, closed)
- Case lifecycle: `created_at`, `updated_at`, `closed_at`, `closed_by`
- Case-Alert junction: Links cases to alerts (OpenSearch documents)
- Foreign keys: `detection_schema_id` (stable) and `detection_schema_version_id` (version)

**OpenSearch**:
- Daily time-based indices: `telhawk-events-YYYY.MM.DD`, `telhawk-alerts-YYYY.MM.DD`
- OCSF-optimized mappings (nested objects for actors, devices, etc.)
- Retention managed via index lifecycle policies
- Query pattern: `telhawk-events-*` for searches across all indices

### Error Handling and Reliability

**Dead Letter Queue (DLQ)**:
- File-based storage at `/var/lib/telhawk/dlq`
- Captures normalization and storage failures
- Preserves full event context for debugging/replay
- API endpoints: `GET /dlq/list`, `POST /dlq/purge`
- Metrics exposed via health endpoint

**Retry Strategy**:
- Ingest → Core: 3 attempts, exponential backoff (~700ms total)
- Core → Storage: 3 attempts, exponential backoff
- Retries on 5xx, 429, network errors
- No retry on 4xx client errors (except 429)

**Rate Limiting**:
- Redis-backed sliding window algorithm
- IP-based (pre-auth) and token-based (post-auth)
- Returns HTTP 429 when exceeded
- Graceful degradation if Redis unavailable

### Observability

**Health Checks**:
- All services expose `/healthz` or `/readyz` endpoints

**Metrics** (Prometheus format at `/metrics`):
- Event processing: `events_total`, `normalization_duration`, `storage_duration`
- Queue depth: `queue_depth`, `queue_capacity`
- Rate limiting: `rate_limit_hits_total`
- Acks: `acks_pending`, `acks_completed_total`

### Running Tests

```bash
# Run all tests
go test ./...

# Run with verbose output
go test -v ./...

```

## CLI Tool (thawk)

The CLI uses Cobra for command structure:

```bash
# Authentication
thawk auth login -u <username> -p <password>
thawk auth whoami
thawk auth logout

# HEC token management
thawk token create --name <token-name>
thawk token list
thawk token revoke <token-id>

# Event ingestion
thawk ingest send --message "event text" --token <hec-token>

# Search queries
thawk search --query "severity:high" --from 1h
```

**Key Files:**
- `cli/cmd/root.go`: Root command and global flags
- `cli/cmd/auth.go`, `cli/cmd/token.go`, etc.: Subcommands
- `cli/internal/config/config.go`: CLI configuration (~/.thawk/config.yaml)

## Code Generation

### OCSF Normalizer Generator

Location: `tools/normalizer-generator/`

Regenerate normalizers after OCSF schema updates:

```bash
cd tools/normalizer-generator
go run main.go

# Output: core/internal/normalizer/generated/*.go (77 files)
```

The generator:
- Reads OCSF schema from `ocsf-schema/` directory
- Generates one normalizer per event class
- Creates intelligent field mappings
- Outputs registration code for the normalizer registry

## Common Development Patterns

### Adding a New Service

1. Create service directory with standard structure:
   ```
   newservice/
   ├── cmd/newservice/main.go
   ├── internal/
   │   ├── config/config.go
   │   ├── handlers/handlers.go
   │   └── ...
   ├── Dockerfile
   ├── config.yaml
   └── go.mod
   ```

2. Add to `docker-compose.yml` with health checks and dependencies
3. Add TLS certificate generation if needed
4. Follow environment variable naming: `NEWSERVICE_SECTION_KEY`

### Adding Database Migrations

1. Create numbered migration files in `auth/migrations/`:
   - `NNN_description.up.sql`
   - `NNN_description.down.sql`

2. Migrations run automatically on auth service startup
3. Use PostgreSQL best practices: indexes, constraints, comments

## Security Considerations

**Network Exposure:**
- **Minimal Attack Surface**: Only web (3000) and ingest (8088) exposed externally
- **No Direct Service Access**: Auth, query, core, and storage services ONLY accessible via Docker network
- **Self-Registration Disabled**: User accounts must be created by administrators (registration endpoint disabled)
- **Admin Access**: All administrative operations require authentication via web UI or thawk CLI

**Authentication & Authorization:**
- JWT secrets MUST be set via `AUTH_JWT_SECRET` environment variable
- HEC tokens are random UUIDs, stored hashed in database
- All auth events forwarded to SIEM for audit trail (nonrepudiation)
- Audit log table captures all authentication/authorization events with HMAC signatures

**Transport Security:**
- TLS MUST be enabled in production (`*_TLS_ENABLED=true`)
- PostgreSQL uses SSL/TLS in production (`sslmode=require`)
- OpenSearch uses TLS with client certificates

**Operational Security:**
- Default passwords in `docker-compose.yml` MUST be changed for production
- Rate limiting prevents abuse of ingestion endpoints
- Dead Letter Queue captures failed events for forensic analysis

## Documentation

Key documentation files:
- `README.md`: Overview, quick start, architecture
- `docs/CONFIGURATION.md`: Complete configuration reference
- `docs/CLI_CONFIGURATION.md`: CLI usage guide
- `DOCKER.md`: Docker commands and troubleshooting
- `TODO.md`: Development roadmap and recent accomplishments
- Individual service READMEs in service directories

## Web Frontend

The web UI is a React application with:
- **Backend**: Go server in `web/backend/` (port 3000)
- **Frontend**: React app in `web/frontend/`
- **Build**: Frontend built and served as static files by backend
- **Features**: Search console, event table, OCSF field inspection, severity color-coding

Frontend development:
```bash
cd web/frontend
npm install
npm start  # Development server
npm run build  # Production build
```

## Default Credentials

**Database (development)**:
- PostgreSQL: `telhawk:telhawk-auth-dev@auth-db:5432/telhawk_auth`
- OpenSearch: `admin:TelHawk123!`

**Default User (created by migration)**:
- Username: `admin`
- Password: `admin123`
- Email: `admin@telhawk.local`
- Roles: `[admin]`
