#!/bin/bash
# Smart wrapper for thawk CLI
# - If Go is installed and devtools is not running: build thawk locally and copy to devtools image
# - If Go is not installed or devtools is running: rebuild devtools image with thawk
# - Execute thawk command via devtools container

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CLI_DIR="$PROJECT_ROOT/cli"
BIN_DIR="$PROJECT_ROOT/bin"
THAWK_BINARY="$BIN_DIR/thawk"

# Check if devtools container is running
is_devtools_running() {
    docker ps --filter "name=telhawk-devtools" --filter "status=running" --format "{{.Names}}" | grep -q "telhawk-devtools"
}

# Check if Go compiler is available
has_go_compiler() {
    command -v go >/dev/null 2>&1
}

# Build thawk binary locally
build_thawk_locally() {
    echo "Building thawk locally..." >&2
    cd "$CLI_DIR"
    CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o "$THAWK_BINARY" .
    echo "✓ Built thawk binary at $THAWK_BINARY" >&2
}

# Copy thawk binary to devtools image
copy_to_devtools() {
    echo "Updating thawk in devtools image..." >&2

    # Create a temporary Dockerfile that adds the binary to the existing image
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT

    cat > "$temp_dir/Dockerfile" <<'EOF'
FROM telhawk-stack-devtools:latest
COPY thawk /usr/local/bin/thawk
RUN chmod +x /usr/local/bin/thawk
EOF

    cp "$THAWK_BINARY" "$temp_dir/"

    # Build the updated image
    docker build -q -t telhawk-stack-devtools:latest -f "$temp_dir/Dockerfile" "$temp_dir" >&2

    echo "✓ Updated devtools image with new thawk binary" >&2
}

# Rebuild devtools image from scratch with thawk included
rebuild_devtools_with_thawk() {
    echo "Rebuilding devtools image with thawk..." >&2

    # First build thawk in a builder container
    docker build -t telhawk-thawk-builder \
        --target builder \
        -f "$PROJECT_ROOT/cli/Dockerfile" \
        "$PROJECT_ROOT" >/dev/null 2>&1

    # Extract the binary
    local temp_dir=$(mktemp -d)
    trap "rm -rf $temp_dir" EXIT

    docker create --name thawk-temp telhawk-thawk-builder >/dev/null 2>&1 || true
    docker cp thawk-temp:/build/cli/thawk "$temp_dir/" 2>/dev/null || {
        docker rm thawk-temp >/dev/null 2>&1 || true
        echo "Error: Failed to extract thawk binary" >&2
        return 1
    }
    docker rm thawk-temp >/dev/null 2>&1 || true

    # Update devtools Dockerfile to include thawk
    cat > "$temp_dir/Dockerfile.devtools" <<'EOF'
FROM alpine:latest

RUN apk add --no-cache bash curl jq wget

WORKDIR /app

# Copy thawk binary
COPY thawk /usr/local/bin/thawk
RUN chmod +x /usr/local/bin/thawk

CMD ["/bin/bash"]
EOF

    # Build new devtools image
    docker build -t telhawk-stack-devtools:latest \
        -f "$temp_dir/Dockerfile.devtools" \
        "$temp_dir" >/dev/null 2>&1

    echo "✓ Rebuilt devtools image with thawk" >&2
}

# Parse arguments to detect rules directory (--from-rules flag or positional for list-rules)
parse_rules_path() {
    local args=("$@")
    local rules_path=""
    local modified_args=()
    local in_list_rules=false

    # Check if this is a "seeder list-rules" command
    for arg in "${args[@]}"; do
        if [[ "$arg" == "list-rules" ]]; then
            in_list_rules=true
            break
        fi
    done

    for ((i=0; i<${#args[@]}; i++)); do
        if [[ "${args[$i]}" == "--from-rules" ]] && [[ $((i+1)) -lt ${#args[@]} ]]; then
            # Handle --from-rules flag
            local path="${args[$((i+1))]}"
            if [[ ! "$path" =~ ^/ ]]; then
                rules_path="$(cd "$PROJECT_ROOT" && realpath "$path")"
                modified_args+=("--from-rules")
                modified_args+=("/rules")
                ((i++))
            else
                modified_args+=("${args[$i]}")
            fi
        elif [[ "$in_list_rules" == true ]] && [[ "${args[$i]}" != "seeder" ]] && [[ "${args[$i]}" != "list-rules" ]] && [[ "${args[$i]}" != -* ]]; then
            # Handle positional argument for list-rules (if it's not a flag)
            local path="${args[$i]}"
            if [[ ! "$path" =~ ^/ ]]; then
                rules_path="$(cd "$PROJECT_ROOT" && realpath "$path")"
                modified_args+=("/rules")
            else
                modified_args+=("${args[$i]}")
            fi
        else
            modified_args+=("${args[$i]}")
        fi
    done

    # Export results
    export RULES_PATH="$rules_path"
    export MODIFIED_ARGS=("${modified_args[@]}")
}

# Main logic
main() {
    # Ensure we're in the project root
    cd "$PROJECT_ROOT"

    # Parse arguments to detect rules path
    parse_rules_path "$@"

    # Determine build strategy
    if is_devtools_running; then
        # Container is running, we need to rebuild the image
        echo "Devtools container is running, rebuilding image..." >&2
        rebuild_devtools_with_thawk
    elif has_go_compiler; then
        # Go is available and container not running, build locally
        build_thawk_locally
        copy_to_devtools
    else
        # No Go compiler, must rebuild image
        rebuild_devtools_with_thawk
    fi

    # Build docker run command
    # All CLI operations go through the web backend for consistent access
    local docker_cmd=(
        docker run --rm
        --network telhawk-stack_telhawk
        -e THAWK_AUTH_URL=http://web:3000
        -e THAWK_INGEST_URL=http://ingest:8088
        -e THAWK_QUERY_URL=http://web:3000
        -e THAWK_RULES_URL=http://web:3000
        -e THAWK_ALERTING_URL=http://web:3000
        -v "$HOME/.thawk:/root/.thawk"
    )

    # If we detected a rules path, mount it
    if [[ -n "$RULES_PATH" ]]; then
        docker_cmd+=(-v "$RULES_PATH:/rules:ro")
    fi

    # If .hec-token file exists, mount it and set HEC_TOKEN env var
    if [[ -f "$PROJECT_ROOT/.hec-token" ]]; then
        local token=$(cat "$PROJECT_ROOT/.hec-token")
        docker_cmd+=(-e "HEC_TOKEN=$token")
    fi

    docker_cmd+=(
        telhawk-stack-devtools:latest
        thawk "${MODIFIED_ARGS[@]}"
    )

    # Execute thawk command via devtools
    "${docker_cmd[@]}"
}

main "$@"
