package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// generateObjects generates Go files for all OCSF object types.
func generateObjects(outputDir string) error {
	objectsSchemaDir := filepath.Join(*schemaDir, "objects")
	objectFiles, err := os.ReadDir(objectsSchemaDir)
	if err != nil {
		return fmt.Errorf("read objects dir: %w", err)
	}

	totalObjects := 0
	for _, objectFile := range objectFiles {
		if !strings.HasSuffix(objectFile.Name(), ".json") {
			continue
		}

		objectPath := filepath.Join(objectsSchemaDir, objectFile.Name())
		object, err := loadObjectSchema(objectPath)
		if err != nil {
			if *verbose {
				fmt.Printf("Warning: cannot load object %s: %v\n", objectFile.Name(), err)
			}
			continue
		}

		// Skip base/internal objects (starting with _)
		if strings.HasPrefix(object.Name, "_") {
			continue
		}

		if err := generateObjectFile(object, outputDir); err != nil {
			if *verbose {
				fmt.Printf("Warning: cannot generate object %s: %v\n", object.Name, err)
			}
			continue
		}

		totalObjects++
		if *verbose {
			fmt.Printf("Generated object: %s\n", object.Name)
		}
	}

	return nil
}

// generateObjectFile generates a Go file for an OCSF object type.
func generateObjectFile(object *ObjectSchema, outputDir string) error {
	var buf strings.Builder

	// Package and imports
	buf.WriteString(generateFileHeader())
	buf.WriteString("package objects\n\n")

	// We'll add fmt import conditionally later if needed for validation
	needsFmt := false

	structName := toGoStructName(object.Name)
	buf.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Flatten parent attributes instead of embedding to avoid JSON marshaling conflicts
	// Collect all attributes (parent + child) into a single map
	allAttrs := make(map[string]json.RawMessage)

	// Load parent attributes first if extends is specified
	if object.Extends != "" && !strings.HasPrefix(object.Extends, "_") {
		parentPath := filepath.Join(*schemaDir, "objects", object.Extends+".json")
		if parentObject, err := loadObjectSchema(parentPath); err == nil {
			// Add parent attributes (child will override if redefined)
			for attrName, rawAttr := range parentObject.Attributes {
				allAttrs[attrName] = rawAttr
			}
		}
	}

	// Add/override with child attributes
	for attrName, rawAttr := range object.Attributes {
		allAttrs[attrName] = rawAttr
	}

	// Sort attributes for consistent output
	attrs := make([]string, 0, len(allAttrs))
	for name := range allAttrs {
		attrs = append(attrs, name)
	}
	sort.Strings(attrs)

	for _, attrName := range attrs {
		rawAttr := allAttrs[attrName]

		// Try to parse as AttributeRef
		var attr AttributeRef
		if err := json.Unmarshal(rawAttr, &attr); err != nil {
			continue
		}

		fieldName := toGoFieldName(attrName)
		goType := inferGoTypeSimple(attrName)
		jsonTag := attrName

		omit := ""
		if attr.Requirement == "optional" || attr.Requirement == "recommended" {
			omit = ",omitempty"
		}

		buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", fieldName, goType, jsonTag, omit))
	}

	buf.WriteString("}\n\n")

	// Generate Validate method for objects (use flattened attributes)
	validatorCode := generateValidatorForObjectWithAttrs(object, allAttrs)

	// Check if we need fmt import based on whether validation uses it
	needsFmt = strings.Contains(validatorCode, "fmt.Errorf")

	// Build final output with conditional fmt import
	var finalBuf strings.Builder
	finalBuf.WriteString(generateFileHeader())
	finalBuf.WriteString("package objects\n\n")
	if needsFmt {
		finalBuf.WriteString("import \"fmt\"\n\n")
	}
	// Add the struct definition and validator (skip the header we already wrote)
	structStart := strings.Index(buf.String(), "type "+structName)
	if structStart >= 0 {
		finalBuf.WriteString(buf.String()[structStart:])
	}
	finalBuf.WriteString(validatorCode)

	// Write to file
	outputPath := filepath.Join(outputDir, toGoFileName(object.Name))
	return os.WriteFile(outputPath, []byte(finalBuf.String()), 0644)
}

// generateObjectPlaceholders generates placeholder types for object references.
// This function is kept for compatibility but is no longer used as we generate
// actual objects from the schema.
func generateObjectPlaceholders(objectTypes map[string]bool, outputDir string) error {
	var buf strings.Builder

	buf.WriteString("// Code generated by ocsf-generator. DO NOT EDIT.\n")
	buf.WriteString("// These are placeholder types for OCSF objects.\n")
	buf.WriteString("// For full OCSF compliance, replace with complete implementations\n")
	buf.WriteString("// from ocsf-schema/objects/ directory.\n\n")
	buf.WriteString("package objects\n\n")

	// Sort for consistent output
	types := make([]string, 0, len(objectTypes))
	for t := range objectTypes {
		types = append(types, t)
	}
	sort.Strings(types)

	buf.WriteString("// Placeholder object types - implement these from OCSF schema\n\n")
	for _, typeName := range types {
		buf.WriteString(fmt.Sprintf("// %s is a placeholder for the OCSF %s object\n", typeName, typeName))
		buf.WriteString(fmt.Sprintf("type %s struct{}\n\n", typeName))
	}

	outputPath := filepath.Join(outputDir, "placeholders.go")
	return os.WriteFile(outputPath, []byte(buf.String()), 0644)
}
