package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// generateMappings creates a comprehensive mappings file for OCSF UIDs to names.
func generateMappings(categories Categories, outputDir string) error {
	var buf strings.Builder

	buf.WriteString("// Code generated by ocsf-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package ocsf\n\n")

	// Generate CategoryName function
	buf.WriteString("// CategoryName returns the human-readable category name from category_uid.\n")
	buf.WriteString("func CategoryName(categoryUID int) string {\n")
	buf.WriteString("\tswitch categoryUID {\n")

	// Sort categories for consistent output
	var catKeys []string
	for key := range categories.Attributes {
		catKeys = append(catKeys, key)
	}
	sort.Strings(catKeys)

	for _, key := range catKeys {
		cat := categories.Attributes[key]
		buf.WriteString(fmt.Sprintf("\tcase %d:\n\t\treturn %q\n", cat.UID, cat.Caption))
	}

	buf.WriteString("\tdefault:\n\t\treturn \"Unknown\"\n")
	buf.WriteString("\t}\n}\n\n")

	// Generate ClassName function
	buf.WriteString("// ClassName returns the human-readable class name from class_uid.\n")
	buf.WriteString("func ClassName(classUID int) string {\n")
	buf.WriteString("\tswitch classUID {\n")

	// Collect all class mappings from event schema
	classMap := make(map[int]string)
	schemaEventsDir := filepath.Join(*schemaDir, "events")
	categoryDirs, err := os.ReadDir(schemaEventsDir)
	if err != nil {
		return fmt.Errorf("read events dir: %w", err)
	}

	for _, categoryDir := range categoryDirs {
		if !categoryDir.IsDir() {
			continue
		}

		categoryName := categoryDir.Name()
		categoryPath := filepath.Join(schemaEventsDir, categoryName)
		categoryUID := getCategoryUID(categoryName, categories)

		eventFiles, err := os.ReadDir(categoryPath)
		if err != nil {
			continue
		}

		for _, eventFile := range eventFiles {
			if !strings.HasSuffix(eventFile.Name(), ".json") {
				continue
			}

			if eventFile.Name() == categoryName+".json" {
				continue
			}

			eventPath := filepath.Join(categoryPath, eventFile.Name())
			class, err := loadEventClass(eventPath)
			if err != nil {
				continue
			}

			fullUID := categoryUID*1000 + class.UID
			classMap[fullUID] = class.Caption
		}
	}

	// Sort class UIDs for consistent output
	var classUIDs []int
	for uid := range classMap {
		classUIDs = append(classUIDs, uid)
	}
	sort.Ints(classUIDs)

	for _, uid := range classUIDs {
		buf.WriteString(fmt.Sprintf("\tcase %d:\n\t\treturn %q\n", uid, classMap[uid]))
	}

	buf.WriteString("\tdefault:\n\t\treturn \"Unknown\"\n")
	buf.WriteString("\t}\n}\n\n")

	// Generate ActivityName function
	buf.WriteString("// ActivityName returns the human-readable activity name from class_uid and activity_id.\n")
	buf.WriteString("func ActivityName(classUID int, activityID int) string {\n")
	buf.WriteString("\t// Format: class_uid * 100 + activity_id for lookup key\n")
	buf.WriteString("\tkey := classUID*100 + activityID\n")
	buf.WriteString("\tswitch key {\n")

	// Collect activity mappings from event schemas
	activityMap := make(map[int]string)

	for _, categoryDir := range categoryDirs {
		if !categoryDir.IsDir() {
			continue
		}

		categoryName := categoryDir.Name()
		categoryPath := filepath.Join(schemaEventsDir, categoryName)
		categoryUID := getCategoryUID(categoryName, categories)

		eventFiles, err := os.ReadDir(categoryPath)
		if err != nil {
			continue
		}

		for _, eventFile := range eventFiles {
			if !strings.HasSuffix(eventFile.Name(), ".json") {
				continue
			}

			if eventFile.Name() == categoryName+".json" {
				continue
			}

			eventPath := filepath.Join(categoryPath, eventFile.Name())
			class, err := loadEventClass(eventPath)
			if err != nil {
				continue
			}

			fullClassUID := categoryUID*1000 + class.UID

			// Extract activity_id enum if present
			if rawActivityAttr, ok := class.Attributes["activity_id"]; ok {
				var activityAttr AttributeRef
				if err := json.Unmarshal(rawActivityAttr, &activityAttr); err == nil {
					for actIDStr, enumVal := range activityAttr.Enum {
						var actID int
						fmt.Sscanf(actIDStr, "%d", &actID)
						key := fullClassUID*100 + actID
						activityMap[key] = enumVal.Caption
					}
				}
			}
		}
	}

	// Sort activity keys for consistent output
	var activityKeys []int
	for key := range activityMap {
		activityKeys = append(activityKeys, key)
	}
	sort.Ints(activityKeys)

	for _, key := range activityKeys {
		buf.WriteString(fmt.Sprintf("\tcase %d:\n\t\treturn %q\n", key, activityMap[key]))
	}

	buf.WriteString("\tdefault:\n\t\treturn \"\"\n")
	buf.WriteString("\t}\n}\n")

	outputPath := filepath.Join(outputDir, "mappings.go")
	return os.WriteFile(outputPath, []byte(buf.String()), 0644)
}
